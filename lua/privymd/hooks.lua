local Block = require("privymd.block")
local GPG = require("privymd.gpg_async")
local Front = require("privymd.frontmatter")
local log = require("privymd.utils.logger")
log.set_log_level("debug")

local M = {}

-- cache local de la passphrase pour la session
local _cached_passphrase = nil

-- üîê Demande (ou r√©cup√®re du cache) la passphrase
local function get_passphrase()
	if _cached_passphrase then
		return _cached_passphrase
	end
	_cached_passphrase = vim.fn.inputsecret("Passphrase GPG : ")
	return _cached_passphrase
end

function M.decrypt_buffer()
	log.trace("D√©chiffrement du buffer")
	local blocks = Block.find_blocks()

	if #blocks == 0 then
		log.trace("Aucun bloc trouv√©.")
		return
	end

	vim.schedule(function()
		log.info("D√©chiffrement des blocs GPG en cours‚Ä¶")
	end)

	local passphrase = get_passphrase()

	for _, block in ipairs(blocks) do
		log.trace("D√©hiffre le bloc " .. _ .. "‚Ä¶")
		GPG.decrypt_async(block.content, passphrase, function(plaintext)
			if plaintext then
				Block.set_block_content(block.start, block.end_, plaintext)
			end
		end)
	end
end

function M.encrypt_buffer(buf_lines)
	log.trace("Chiffrement du buffer‚Ä¶")
	local blocks = Block.find_blocks()

	if #blocks == 0 then
		log.trace("Aucun bloc GPG d√©tect√©.")
		return
	end

	local recipient = Front.get_file_recipient()
	if not recipient then
		log.trace("Pas de destinataire de chiffrement d√©fini.")
		return
	end
	log.debug("Recipient: " .. recipient)

	for _, block in ipairs(blocks) do
		local ciphertext = GPG.encrypt_sync(block.content, recipient)
		if not ciphertext then
			log.error("√âchec du chiffrement du bloc.")
			return
		end
		Block.set_block_content(block.start, block.end_, ciphertext, buf_lines)
	end

	return buf_lines
end

function M.save_buffer(buf_lines)
	if not buf_lines or #buf_lines == 0 then
		log.error("Aucune donn√©e √† √©crire (buffer vide ou invalide).")
		return
	end
	local filename = vim.api.nvim_buf_get_name(0)
	local ok, err = pcall(vim.fn.writefile, buf_lines, filename)
	if not ok then
		log.error("Erreur d'√©criture : " .. tostring(err))
		return
	end

	-- Marque le buffer comme sauvegard√©
	vim.bo.modified = false
	log.info("Fichier chiffr√© √©crit, buffer conserv√© en clair.")
end

function M.encrypt_and_save_buffer()
	-- Cr√©e une copie du buffer pour construire le texte chiffr√©
	local plaintext = vim.api.nvim_buf_get_lines(0, 0, -1, false)

	-- Chiffrement
	local ciphertext = M.encrypt_buffer(plaintext)

	-- Sauvegarde
	M.save_buffer(ciphertext or plaintext)
end

-- üßπ R√©initialiser le cache de passphrase (optionnel)
function M.clear_passphrase()
	_cached_passphrase = nil
	log.info("Passphrase oubli√©e de la session.")
end

return M
